// CQG Web API server protocol

package WebAPI_1;

// Last changes were made on 24 June 2015
// Version 1.24 - (version number is constructed as 'MAJOR.MINOR' from the following enums)
enum ProtocolVersionMajor
{
	// Major number change is required for backward incompatible protocol versions (new 'proto' file is necessary)
	PROTOCOL_VERSION_MAJOR = 1;
}
enum ProtocolVersionMinor
{
	// Minor number is increased for backward compatible protocol versions when new messages and/ or fields are
	// added without removing/ changing any existing messages and fields (new 'proto' file is not created)	
	PROTOCOL_VERSION_MINOR = 24;
}

// Protocol rules:
// 1)  CamelCase with an initial capital is used for message names while fields are lowercase underscore_separated_names
//     (see https://developers.google.com/protocol-buffers/docs/style)
// 3)  Key numbers for existing fields must stay the same between minor protocol version changes.
// 4)  Negative values for enums and key numbers are prohibited.
// 5)  Only explicit signed (e.g. sint32) and unsigned (e.g. uint64) integer types must be used. Usage of implicit signed integer
//     types (e.g. int16) is prohibited since they are not supported by JS client library and consume a lot of space for 
//     negative values.
// 6)  Unsigned types should be used for fields that cannot have negative values. This allows to minimize their size.
// 7)  Field numbers < 16 takes one byte for a key/ wire-type header so numbers > 16 should be used for optional and infrequently used fields.
//     do not 'reserve' field numbers without real reasons.
//     See https://developers.google.com/protocol-buffers/docs/encoding for details.
// 8)  'Result' suffix is used in responses when only a single response is possible.
// 9)  'Status' suffix is used a separate message for a status of a subscription when subscriptions are not optional.
// 10) 'Report' suffix is used in responses when 'Result' and 'Data' are combined in a single message and when subscription is optional,
//     this allows to avoid two messages if subscription is not requested.
// 11) Time attributes are 64-bit signed integers that contain offset in milliseconds from base_time attribute of the logon and
//     session restore results.
// 12) Client implementation must be ready to get new values of any field associated with enum specified in this protocol
//     (all these fields are made uint32 to make protocol backward compatible for such changes). So when client gets unknown value it should
//     either ignore it or check whether it relates to failure (e.g. whether it's > 100 for StatusCode/ResultCode fields).


// Client to Server message, must include at least one field.
// Logon, LogonRoutineClient, RestoreSession or ObtainDemoCredentials are required to be the first and the only message after connection.
// Client messages rate is limited, 1000 messages per 10 seconds by default.
// If this rate is exceeded then a user message is sent with details and the connection is closed.
// NOTE: This and other limits mentioned in this protocol are not guaranteed, they are given for reference only
// and are subject to change without prior notice.
message ClientMsg
{
	// Session level messages from client.
	optional Logon logon = 100;
	optional RestoreSession restore_session = 101;
	optional Logoff logoff = 102;
	optional PasswordChange password_change = 103;
	optional ObtainDemoCredentials obtain_demo_credentials = 104;
	optional UserSessionStateRequest user_session_state_request = 105;
	optional Ping ping = 107;
	optional Pong pong = 108;
	optional LogonRoutineClient logon_routine_client = 109;
	optional PasswordChangeRoutineClient password_change_routine_client = 110;

	// Requests for different information with optional subscription for updates.
	// There are the following limits for information requests:
	// 1) Information requests rate is limited, 1000 requests per 100 seconds by default.
	// 2) Number of simultaneous information subscriptions is limited, a separate limit per information request type is used.
	// 3) Number of overall information requests per session is limited, a separate limit per information request type is used.
	repeated InformationRequest information_request = 1;
	
	// Trade routing subscriptions from client.
	// There are the following limits for trade routing subscriptions:
	// 1) Number of simultaneous subscriptions is limited, 200 by default.
	// 2) Total number of either explicitly or implicitly subscribed accounts is limited, 5000 by default.
	//    Any subscription that leads to exceeding this limit is failed.
	repeated TradeSubscription trade_subscription = 2;

	// Order requests.
	// Requests rate is limited, 300 orders per 10 seconds per account by default.
	repeated OrderRequest order_request = 3;

	// Market data subscriptions from client.
	// Subscriptions number is limited, 200 simultaneous subscriptions by default.
	repeated MarketDataSubscription market_data_subscription = 4;

	// Requests for manipulations with user attributes (linked to the user and client_id).
	// There are the following limits for user attributes:
	//  1) storage space is limited, 100 KB by default for a user/client_id pair;
	//  2) requests rate is limited, 10 requests per 100 seconds by default.
	repeated ReadUserAttributeRequest read_user_attribute_request = 5;
	repeated ModifyUserAttributeRequest modify_user_attribute_request = 6;

	// Historical data requests.
	// Number of simultaneous historical requests in processing is limited, 10 by default.
	repeated TimeAndSalesRequest time_and_sales_request = 7;
	repeated TimeBarRequest time_bar_request = 8;
}

// Server to Client message, server can include different fields in a single message
message ServerMsg
{
	// Session level messages from server.
	optional LogonResult logon_result = 100;
	optional RestoreSessionResult restore_session_result = 101;
	optional LoggedOff logged_off = 102;
	optional PasswordChangeResult password_change_result = 103;
	repeated UserMessage user_message = 104;
	optional ObtainDemoCredentialsResult obtain_demo_credentials_result = 105;
	optional UserSessionStateResult user_session_state_result = 106;
	optional Ping ping = 107;
	optional Pong pong = 108;
	optional LogonRoutineServer logon_routine_server = 109;
	optional PasswordChangeRoutineServer password_change_routine_server = 110;

	// Reports with requested information.
	repeated InformationReport information_report = 1;

	// Trade routing messages from server.
	repeated OrderRequestReject order_request_reject = 2;
	repeated TradeSubscriptionStatus trade_subscription_status = 3;
	repeated TradeSnapshotCompletion trade_snapshot_completion = 4;
	repeated OrderStatus order_status = 5;
	repeated PositionStatus position_status = 6;
	repeated CollateralStatus collateral_status = 7;

	// Market data messages from server.
	repeated MarketDataSubscriptionStatus market_data_subscription_status = 8;
	repeated RealTimeMarketData real_time_market_data = 9;

	/// Results of user attributes operations.
	repeated ReadUserAttributeResult read_user_attribute_result = 10;
	repeated ModifyUserAttributeResult modify_user_attribute_result = 11;

	/// Historical data.
	repeated TimeAndSalesReport time_and_sales_report = 12;
	repeated TimeBarReport time_bar_report = 13;
}

////------------------------------------------
//// Session level messaging

// Placeholder message of real-time Collapsing level enumeration (some libraries do not support enumerations outside of messages)
// Collapsing is a mechanism of eliminating some intermediate quotes to present more up-to-date market data
// instead of falling behind.
// It is started dynamically by server if client is not able to consume all requested feed timely
// e.g. because of a narrow network channel or client side hardware/ software issues.
message RealTimeCollapsing
{
	enum Level
	{
		// Collapsing is not not preferred.
		NONE = 0;

		// DOM data is collapsed.
		DOM = 1;

		// DOM and best bid/ ask quotes are collapsed delivering only last BBA but all trades.
		DOM_BBA = 2;

		// DOM, best bid/ ask and trades quotes are collapsed delivering only last values.
		DOM_BBA_TRADES = 3;
	}
}

// Logon into the system and opening a new session.
message Logon
{
	// User login name.
	required string user_name = 1;

	// User's password.
	required string password = 2;

	// User's one time password, might be required according to the user's settings.
	optional string one_time_password = 3;

	// Private label identifies the Firm or Vendor that connects to the server, client_id field value is taken by default.
	optional string private_label = 4;

	// Identifier of a client application as assigned by CQG.
	required string client_id = 5;

	// Version of a client application.
	required string client_version = 6;

	// Optional field that indicates if possible concurrent sessions for this user should be forcedly dropped.
	// If it is set to false then Logon may fail with CONCURRENT_SESSION code.
	// If it is omitted or set to true then concurrent sessions for this user will be dropped.
	optional bool drop_concurrent_session = 7;

	// Maximum allowed real-time market data collapsing level.
	// DOM_BBA_TRADES is a default allowed collapsing level.
	// This field is associated with RealTimeCollapsing.Level enum type.
	optional uint32 collapsing_level = 8;

	// Current protocol version that is used by a client application.
	// It is strongly recommended for client applications to put PROTOCOL_VERSION_MAJOR and PROTOCOL_VERSION_MINOR values from a used protocol file.
	// If version information is not provided then Server assumes client uses 0.x version of a protocol and may disable some new protocol features.
	optional uint32 protocol_version_minor = 9;
	optional uint32 protocol_version_major = 10;
}

// Result of the logon operation (for Logon and LogonRoutineClient messages).
message LogonResult
{
	enum ResultCode
	{
		//// success codes
		// User is logged in to the system.
		SUCCESS = 0;

		//// failure codes (100+)
		// General failure.
		FAILURE = 101;

		// One-time password is required for this user but it was not sent, repeat logon
		// with one-time password.
		NO_ONETIME_PASSWORD = 103;

		// User password is expired, only change password operation is allowed.
		PASSWORD_EXPIRED = 104;

		// Failed because this user has a concurrent session that is
		// not allowed for this application and drop was not requested.
		CONCURRENT_SESSION = 105;

		// Client is redirected to a different server, new server is specified in redirectUrl.
		REDIRECTED = 106;

		// The server does not support the encoding method which was used for password encoding.
		// Can be specified only in response to LogonRoutineClient.password_response message.
		ENCODING_TYPE_NOT_SUPPORTED = 107;

		// The negotiation rules for LogonRoutineClient have been violated, e.g. user has specified several fields at once in one message.
		ROUTINE_ERROR = 108;
	}

	// One of the logon result codes.
	// This field is associated with ResultCode enum type.
	required uint32 result_code = 1;

	// Base time as ISO 8601 string (e.g. '2013-04-03T14:23:20')
	// all other times are number of milliseconds from this base time.
	required string base_time = 2;

	// Token of a new session if logon succeeded.
	optional string session_token = 3;

	// Optional logon result message for failure details.
	optional string text_message = 4;

	// URL for a client to reconnect in case of redirection.
	optional string redirect_url = 5;

	// Current protocol version of server. Normally client application need nothing to do with it.
	required uint32 protocol_version_minor = 6;
	required uint32 protocol_version_major = 7;

	// Unique user identification
	optional sint32 user_id = 8;
}

// Message for multi-step logon which user should use in case if it is required to use encoded password.
// Multi-step logon sequence has the following steps:
//      1) Client initiates logon negotiation by sending LogonRoutineClient.logon_init message to the server.
//      2) Server sends one or more LogonRoutineServer.password_request messages (this step may repeat after step #3).
//      3) Client sends list of LogonRoutineClient.password_response back to the server.
//      4) Server optionally asks accept trader's agreement (LogonRoutineServer.trader_agreement_url).
//      5) Client responds with LogonRoutineClient.trader_agreement_accepted equal to True
//         if the user accepts agreement, False or LogonRoutineClient.abort_logon otherwise.
//      6) Server sends LogonRoutineServer.logon_result as the final message of the negotiation with the results.
//   Client may stop the negotiation by sending LogonRoutineClient.abort_logon message in response to any server
//      LogonRoutineServer.password_request or LogonRoutineServer.trader_agreement_url requests.
// NOTE: only one of fields has to be specified.
message LogonRoutineClient
{
	// Initiating of multi-step logon process by client.
	optional LogonInit logon_init = 1;

	// List of passwords in response to request from server.
	// The number of passwords in response should be equal to the number of passwords in request from server.
	repeated PasswordResponse password_response = 2;

	// True means user has accepted the trader agreement.
	optional bool trader_agreement_accepted = 3;

	// Aborting of multi-step logon process by client.
	optional AbortRoutine abort_logon = 4;
}

// Response to the LogonRoutineClient message. Only one of fields is specified.
message LogonRoutineServer
{
	// Final message of the negotiation with the results.
	optional LogonResult logon_result = 1;

	// List of requested passwords.
	repeated PasswordRequest password_request = 2;

	// URL pointing to the location of help information for this version of agreement.
	// Specified if user should accept trader's agreement in order to continue logon process.
	optional string trader_agreement_url = 3;
}

// Message for multi-step password change which user should use in case if it is required to use encoded password.
// Multi-step password change sequence has the following steps:
//      1) Client initiates password change procedure by sending PasswordChangeRoutineClient.init_password_change to the server.
//      2) Server sends one or more PasswordChangeRoutineServer.password_request messages (this step may repeat after step #3).
//      3) Client sends list of PasswordChangeRoutineClient.password_response back to the server.
//      4) Server sends PasswordChangeRoutineServer.password_change_result as the final message of the negotiation with the results.
//   Client may stop the negotiation by sending PasswordChangeRoutineClient.abort_password_change message in response to any server
//      PasswordChangeRoutineServer.password_request message.
// NOTE: only one of fields has to be specified.
message PasswordChangeRoutineClient
{
	// True means user has decided to initiate password changing procedure.
	optional bool init_password_change = 1;

	// List of passwords in response to request from server.
	// The number of passwords in response should be equal to the number of passwords in request from server.
	repeated PasswordResponse password_response = 2;

	// Aborting of multi-step password change process by client.
	optional AbortRoutine abort_password_change = 3;
}

// Response to the PasswordChangeRoutineClient message. Only one of fields is specified.
message PasswordChangeRoutineServer
{
	// List of requested passwords.
	repeated PasswordRequest password_request = 1;

	// Final message of the negotiation with the results.
	optional PasswordChangeResult password_change_result = 2;

	// URL pointing to location of help information for this version of agreement.
	// Specified if user should accept trader agreement in order to continue logon process.
	optional string trader_agreement_url = 3;
}

// This message indicates that user has decided to abort the logon or password change processes.
message AbortRoutine
{
	// Reason of logon or password change routine abort.
	optional string comment = 1;
}

// Initiating of multi-step logon process by client. See description of fields in Logon message.
message LogonInit
{
	required string user_name = 1;
	optional string private_label = 2;
	required string client_id = 3;
	required string client_version = 4;
	optional bool drop_concurrent_session = 5;
	optional uint32 collapsing_level = 6;

	optional uint32 protocol_version_minor = 7;
	optional uint32 protocol_version_major = 8;
}

// Parameters of requesting password from user.
message PasswordRequest
{
	enum PasswordType
	{
		// Currently used password.
		STATIC = 1;

		// One-time password.
		ONE_TIME = 2;

		// New password that user wants to use. Can be specified only in result of PasswordChangeRoutineClient.
		NEW_STATIC = 3;

		// Currently used password and new password that user wants to use. Can be specified only in result of PasswordChangeRoutineClient.
		CUR_AND_NEW_STATIC = 4;
	}

	// ID of a request.
	required uint32 request_id = 1;

	// Type of password which server requests from the user.
	// This field is associated with PasswordType enum type.
	required uint32 password_type = 2;

	// Commonly understood code that can be used to show an additional localized prompt for certain password types.
	optional string user_prompt_type = 3;

	// Alternate English text for clients which do not recognize user_prompt_type. This text can be displayed as-is to the user.
	// NOTE: user_prompt_type and user_prompt_type_alt are a pair (so either none or both are provided).
	optional string user_prompt_type_alt = 4;

	// Text that should be displayed to the user as-is along with the localized prompt implied by user_prompt_type.
	// If user_prompt_type_alt is used instead, this text should be displayed after it.
	// user_prompt will only be provided if user_prompt_type and user_prompt_type_alt are provided, but it is optional even then.
	optional string user_prompt = 5;

	// Set of supported encodings for this request. Client should choose the encoding with highest priority from among those it implements.
	repeated Encoding encoding = 6;
}

// Response to the PasswordRequest message.
message PasswordResponse
{
	// ID of corresponding password request.
	required uint32 request_id = 1;

	// Commonly understood string that identifies the password encoding method.
	required string encoding_type = 2;

	// User's password encoded with specified encoding method.
	required string password = 3;
}

// Description of the encoding method.
message Encoding
{
	// Commonly understood string that identifies the encoding method.
	required string encoding_type = 1;

	// The priority for this encoding, value 1 is highest priority, 2 is next priority, etc.
	required uint32 priority_rank = 2;

	// Encoding parameters for this encoding method.
	repeated EncodingParameter encoding_parameter = 3;
}

// The encoding parameter.
message EncodingParameter
{
	// Encoding parameter's name.
	required string name = 1;

	// Encoding parameter's value.
	required string value = 2;
}

// Client request to restore session because of accidental disconnect.
// NOTE: this message is used only to avoid prompting user for [one-time] password after disconnect
// client application has to [re-]subscribe and [re-]request necessary data after restoring this session.
message RestoreSession
{
	// Token of the session to restore, it has limited lifetime after disconnect.
	required string session_token = 1;
}

// Result of session restore attempt.
message RestoreSessionResult
{
	enum ResultCode
	{
		//// success codes
		// User is logged in to the system.
		SUCCESS = 0;

		//// failure codes (100+)
		// Session is unknown to a server, client must perform standard logon procedure.
		UNKNOWN_SESSION = 101;
	}

	// Session restore result.
	// This field is associated with ResultCode enum type.
	required uint32 result_code = 1;

	// Session base time (see LogonResult.base_time).
	required string base_time = 2;
}

// Client request to logoff from the system and close the session.
message Logoff
{
	// Optional logoff reason.
	optional string text_message = 1;
}

// Server notification about closing user's session,
// server closes connection after this message.
message LoggedOff
{
	enum LogoffReason
	{
		// User is logged off by client request.
		BY_REQUEST = 1;

		// User is redirected to another URL.
		REDIRECTED = 2;

		// System logged off the user because of some server side reason.
		FORCED = 3;

		// System logged off the user because this session was re-assigned to another connection
		// that took it over by 'restore session' operation
		REASSIGNED = 4;
	}

	// One of the logoff reasons.
	// This field is associated with LogoffReason enum type.
	required uint32 logoff_reason = 1;

	// Optional logoff details.
	optional string text_message = 2;

	// URL for redirection.
	optional string redirect_url = 3;
}

// Message to change user's password.
message PasswordChange
{
	// Currently used password.
	required string old_password = 1;

	// New password that user wants to use.
	required string new_password = 2;
}

// Result of user password change (for PasswordChange and PasswordChangeRoutineClient messages).
message PasswordChangeResult
{
	// Password change result.
	enum ResultCode
	{
		/// success codes
		// User password is changed successfully.
		SUCCESS = 0;

		/// failure codes (100+)
		// Incorrect user name or password.
		FAILURE = 101;

		// The server does not support the encoding method which was used for password encoding.
		// Can be specified only in response to PasswordChangeRoutineClient.password_response message.
		ENCODING_TYPE_NOT_SUPPORTED = 102;

		// The negotiation rules for PasswordChangeRoutineClient have been violated, e.g. user has specified several fields at once in one message.
		ROUTINE_ERROR = 103;
	}
	// This field is associated with ResultCode enum type.
	required uint32 result_code = 1; 

	// Optional failure details.
	optional string text_message = 2;
}

// request for temporary user name and password for demo
message ObtainDemoCredentials
{
	// Identifier of a client application as assigned by CQG.
	required string client_id = 1;

	// User first name
	required string first_name = 2;

	// User second name
	required string second_name = 3;

	// E-mail address of a user who requested demo access.
	required string e_mail = 4;

	// Private label identifies the Firm or Vendor that connects to the server, client_id field value is taken by default.
	optional string private_label = 5;
}

message ObtainDemoCredentialsResult
{
	// Password change result.
	enum ResultCode
	{
		/// success codes (0 - 100)
		SUCCESS = 0;

		/// failure codes (100+)
		FAILURE = 101;
	}
	// This field is associated with ResultCode enum type.
	required uint32 result_code = 1; 

	// demo user name
	optional string user_name = 2;

	// demo password
	optional string password = 3;

	// Optional details.
	optional string text_message = 4;
}

// Text message from server.
message UserMessage
{
	// Type of the message.
	enum MessageType
	{
		// Critical error message.
		CRITICAL_ERROR = 1;

		// Warning.
		WARNING = 2;

		// General information.
		INFO = 3;

		// This message shouldn't be visible for users, only dumped into a log file.
		LOG = 4;
	}
	// This field is associated with MessageType enum type.
	required uint32 message_type = 1;

	// Information about source of the message.
	required string source = 2;

	// Message subject.
	optional string subject = 3;

	// Message text.
	required string text = 4;

	// Optional time when this message is expired, it should be hidden from user after this time (UTC).
	optional sint64 expiration_utc_time = 5;
}

// Request information about user session.
message UserSessionStateRequest
{
	required string session_token = 1;
}

message UserSessionStateResult
{
	// Session token from UserSessionStateRequest.
	required string session_token = 1;

	enum ResultCode
	{
		//// success codes
		// Data for requested session is found.
		SUCCESS = 0;

		//// failure codes (100+)
		// General failure.
		FAILURE = 101;

		// Session is unknown to a server.
		UNKNOWN_SESSION = 102;

		// The user is not allowed to access this data.
		ACCESS_DENIED = 103;
	}

	// This field is associated with ResultCode enum type.
	required uint32 result_code = 2;

	/// User session information.
	optional sint32 user_id = 3;
	optional string username = 4;
}

// Ping request which can be initiated by any side to ensure connection is alive. Both client and
// server sides must respond such request with Pong.
message Ping
{
	// Token routed back in Pong response.
	optional string token = 1;

	// UTC time when this request was composed. Used for network latency diagnostics.
	required sint64 ping_utc_time = 2;
}

// Pong response which must be sent in response on Ping request.
message Pong
{
	// Token passed in Ping request.
	optional string token = 1;

	// Corresponding value from Ping request.
	required sint64 ping_utc_time = 2;

	// UTC time when this response was composed.
	required sint64 pong_utc_time = 3;
}


////------------------------------------------
//// Market and Trade Routing Common messages

message ContractMetadata
{
	// Server assigned ID for a contract, it is not the same across sessions.
	required uint32 contract_id = 1;

	// Full contract symbol.
	required string contract_symbol = 2;

	// Scale to convert prices from this protocol to correct prices
	// (correctPrice = price * correctPriceScale).
	required double correct_price_scale = 3; 

	// Display Price Scale is a number that defines conversion of float correct price to
	// a 'native' integer display format and back
	// Below is the table of possible scale values
	// -------------------------------------------------------
	// | Scale |       Name            |    Description      |
	// -------------------------------------------------------
	// | 0     |One                     |Don't scale         |
	// | 1     |TenMinusOne             |Divide by 10        |
	// | 2     |TenMinusTwo             |Divide by 100       |
	// | 3     |TenMinusThree           |Divide by 1000      |
	// | 4     |TenMinusFour            |Divide by 10000     |
	// | 5     |TenMinusFive            |Divide by 100000    |
	// | 6     |TenMinusSix             |Divide by 1000000   |
	// | 7     |TenMinusSeven           |Divide by 10000000  |
	// | 8     |TenMinusEight           |Divide by 100000000 |
	// | 9     |TenMinusNine            |Divide by 1000000000|
	// | 10    |TenMinusTen             |Divide by 10^10     |
	// | 11    |TenMinusEleven          |Divide by 10^11     |
	// | 12    |TenMinusTwelve          |Divide by 10^12     |
	// | 13    |TenMinusThirteen        |Divide by 10^13     |
	// | 14    |TenMinusFourteen        |Divide by 10^14     |
	// | 15    |TenMinusFifteen         |Divide by 10^15     |
	// | 101   |Halves                  |Divide by 2         |
	// | 102   |Fourths                 |Divide by 4         |
	// | 103   |Eighths                 |Divide by 8         |
	// | 104   |Sixteenths              |Divide by 16        |
	// | 105   |ThirtySeconds           |Divide by 32        |
	// | 106   |SixtyFourths            |Divide by 64        |
	// | 107   |OneHundredTwentyEighths |Divide by 128       |
	// | 108   |TwoHundredFiftySixths   |Divide by 256       |
	// | 109   |FiveHundredTwelths      |Divide by 512       |
	// | 110   |OneThousandTwentyFourths|Divide by 1024      |
	// | 201   |HalfThirtySeconds       |Similar to 64ths    |
	// | 202   |QuarterThirtySeconds    |Similar to 128ths   |
	// | 203   |EighthThirtySeconds     |Similar to 256ths   |
	// | 204   |HalfSixtyFourths        |Similar to 128ths   |
	// | 205   |QuarterSixtyFourths     |Similar to 256ths   |
	// -------------------------------------------------------
	required uint32 display_price_scale = 4;

	// Contract description.
	required string description = 5;

	// Contract display name.
	required string title = 6;

	// Size or a single market tick in correct price format.
	required double tick_size = 7;

	// Contract currency code (ISO 4217 based).
	// Empty string if not applicable (e.g. for indexes).
	required string currency = 8;

	// Contract tick money value in the contract's currency.
	// Zero if not applicable (e.g. for indexes).
	required double tick_value = 9;

	// CFI code (Classification of Financial Instruments, ISO 10962).
	required string cfi_code = 10;

	// True if this contract is the most active one for derivatives.
	optional bool is_most_active = 11;

	// Contract trading date for derivatives
	// (local exchange date in time format, use date part only).
	optional sint64 last_trading_date = 12;

	// Contract first notice date
	// (local exchange date in time format, use date part only).
	optional sint64 first_notice_date = 13;

	// Underlying contract symbol (e.g. for options).
	optional string underlying_contract_symbol = 14;

	// Margin style (for options).
	enum MarginStyle
	{
		// The premium is paid on exercise/ expiry (position is included to OTE calculation).
		FUTURE = 1;

		// Premium is subtracted from account balance when order is filled (position is included to MVO/UPL calculation).
		PREMIUM = 2;
	}
	// This field is associated with MarginStyle enum type.
	optional uint32 margin_style = 15;

	// Name of a group of contracts that share the same properties (e.g. commodity name for futures and options)
	required string instrument_group_name = 16;

	// ID of a session information this contract is related to.
	required sint32 session_info_id = 17;

	// Market Identification Code of the contract (ISO 10383).
	optional string mic = 18;

	// Possible permissions for the user.
	enum Permission
	{
		// User is allowed to subscribe market data up to TRADES_BBA level that will be delivered with a delay.
		DELAYED_BBA_SUBSCRIPTION = 1;

		// User is allowed to subscribe market data up to TRADES_BBA_VOLUMES level.
		BBA_SUBSCRIPTION = 2;

		// User is allowed to subscribe market data up to TRADES_BBA_DOM level.
		DOM_SUBSCRIPTION = 3;

		// User is allowed to trade via at least one authorized account.
		TRADING = 4;
	}
	// This field is associated with Permission enum type.
	// List of the permissions for this contract.
	repeated uint32 permission = 19;

	// if user is allowed to receive only delayed data of the contract 
	// then this parameter is set to the delay value in milliseconds.
	optional sint64 delay = 20;
}

////------------------------------------------
//// Information Requests and Reports

// Request for information.
// There must be only one request type (e.g. accountsRequest and lastStatementBalancesRequest can not be sent at the same time).
message InformationRequest
{
	// ID of a request and optional subscription that should be unique enough to match responses and updates with corresponding requests.
	required uint32 id = 1;

	// If set to true then corresponding reports are also sent when requested information is changed during the session,
	// if set to false then subscription is dropped,
	// if omitted then data is returned without changing subscription status.
	optional bool subscribe = 2;

	// Request for authorized accounts for trading.
	// Only one subscription is possible.
	// Requests rate is limited, 100 per 24 hours by default.
	// Requests are accepted only if the user is not subscribed for this information at the moment.
	optional AccountsRequest accounts_request = 3;

	// Request symbol resolution with optional subscription.
	// Requests rate is limited, 10000 per 24 hours by default.
	// NOTE: subscription is essential to follow active contract switching.
	optional SymbolResolutionRequest symbol_resolution_request = 4;

	// Request for balances from the last statement for all authorized accounts.
	// Only one subscription is possible.
	// Requests rate is limited, 100 per 24 hours by default.
	// Requests are accepted only if the user is not subscribed for this information at the moment.
	optional LastStatementBalancesRequest last_statement_balances_request = 5;

	// Request for currency rates for all brokerages user's accounts belong to.
	// Only one subscription is possible.
	// Requests rate is limited, 100 per 24 hours by default.
	// Requests are accepted only if the user is not subscribed for this information at the moment.
	optional CurrencyRatesRequest currency_rates_request = 6;

	// Request for session information.
	// Number of simultaneous requests in processing is limited, 10 by default.
	// Number of simultaneous session information update subscriptions is limited, 200 by default.
	// Requests are accepted only if the user is not subscribed for this information at the moment.
	optional SessionInformationRequest session_information_request = 7;

	// Request for a list of historical orders according to a search criteria.
	// Number of simultaneous requests in processing is limited, 1 by default.
	// Subscription is not supported for this request.
	optional HistoricalOrdersRequest historical_orders_request = 13;
}

// Report with requested information and subscription updates.
// It will contain only one report type at the same time (related to id).
message InformationReport
{
	// Report ID is equal to a corresponding request and subscription ID.
	required uint32 id = 1;

	// True means that requested data is complete at the moment, false means more report messages are expected for completeness.
	optional bool is_report_complete = 2 [default = true];

	// Optional status code for a request or subscription, status is only sent for initial status and status changes.
	enum StatusCode
	{
		/// success codes  (0 - 99)
		// Request is processed without subscription (subscription was not requested).
		SUCCESS = 0;

		// Request is processed and subscription is established.
		SUBSCRIBED = 1;

		// Subscription is dropped by a client request.
		DROPPED = 2;

		// Unsolicited information update because of subscription.
		UPDATE = 3;

		// Currently subscription is disconnect because of communication issues
		// NOTE: Clients should not resubscribe in this case, the server will restore subscription with 
		// sending SUBSCRIBED status once communication issues are resolved
		DISCONNECTED = 4;

		/// failure codes (100+), subscription (if any) is dropped in case of failure.
		// General failure.
		FAILURE = 101;

		// Requested information is not found.
		NOT_FOUND = 104; 
	}
	// This field is associated with StatusCode enum type.
	required uint32 status_code = 3;

	// Possible details of status or failure.
	optional string text_message = 4;

	// Report with trading accounts.
	optional AccountsReport accounts_report = 5;

	// Resolved symbol initial information or update.
	optional SymbolResolutionReport symbol_resolution_report = 6;

	// Report with balances from the last statement for all authorized accounts.
	optional LastStatementBalancesReport last_statement_balances_report = 7;

	// Report with currency rates per brokerage.
	optional CurrencyRatesReport currency_rates_report = 8;

	// Report with session information.
	optional SessionInformationReport session_information_report = 9;

	// Report with a list of historical orders according to specified parameters.
	optional HistoricalOrdersReport historical_orders_report = 15;
}

// Request for a list of accounts this user is authorized to use and/ or monitor, empty message.
message AccountsRequest
{
}

// Response with a list of authorized accounts grouped by brokerage firms and internal sales series (account groups),
// the same account can not belong to more than one account group.
message AccountsReport
{
	// List or brokerages with accounts the user works with.
	repeated Brokerage brokerage = 1;
}

// List of brokerage accounts.
message Brokerage
{
	// Brokerage firm ID in CQG trade routing system.
	required uint32 id = 1;

	// Brokerage firm name.
	required string name = 2;

	// List of sales series.
	repeated SalesSeries sales_series = 3;
}

// List of accounts in a sales series group.
message SalesSeries
{
	// Sales series number in CQG trade routing system.
	required string number = 1;

	// Sales series name.
	required string name = 2;

	// List of accounts.
	repeated Account account = 3;
}

// Trade routing account data.
message Account
{
	// Account ID in CQG trade routing system.
	required sint32 account_id = 1;

	// Account ID in Brokerage Firm.
	required string brokerage_account_id = 2;

	// Account name in CQG trade routing system.
	required string name = 3;

	// Last statement date for this account
	// (brokerage local date in time format, use date part only).
	required sint64 last_statement_date = 4;

	// True if user can only monitor this account without trading.
	optional bool is_view_only = 5;

	// True if user was unauthorized and is not able to use/ see this account anymore.
	optional bool is_unauthorized = 6;
}

// Request to resolve a symbol pattern or specific symbol identifier to a specific contract with optional subscription for meta-data updates.
// Symbol resolution rules:
//   a) If the requested symbol points to a symbol prefix rather than a specific contract then it is resolved into the most active contract for
//      this symbol prefix (e.g. 'EP' is resolved to 'EPU3').
//      The update is sent when an active contract is changed (e.g. the update might contain the following 'EPZ3')
//   b) If the requested symbol points to a specific contract that is expired already then it is resolved to the most active contract instead 
//      (e.g. 'EPM3' is resolved to 'EPU3').
//      The update  will be sent when an active contract is also expired (e.g. update will contain 'EPZ3' when 'EPU3' is expired).
//   c) If the requested symbol points to a specific contract that is tradable right now then it is resolved to itself and then follows update
//      rules described in (b).
//   d) If requested symbol points to an option instrument without specific month and strike it is resolved to the lead (first non-spot) month
//      of the underlying future or its own front month if the underlying contract is not a future (e.g. 'C.EP' is resolved to 'C.EPU131600'). 
//      Update is sent only when the resolved option contract is expired (strike is not updated to follow underlying contract market price).
//   e) If requested symbol is a symbol prefix that follows '?N' or '??N' (where N is number, e.g. EP?2) then it is resolved to
//      Nth nearest contract.
//      N = 1 means 'front' contract, N = 2 means the nearest contract that follows the front, etc.
//      '?' and '??' are different for futures only and '?' means Nth nearest regular future and '??' means Nth nearest spot or regular future.
//      Update is sent when the front contract expired and replaced with the following contract (relative position change).
//      N = 0 is a special case that means 'most active' contract which works the same way as (a)
// NOTE: Available and active contract lists are updated within 24 hours of an expiring contract's final trading session.
//       Meta-data updates for affected contracts, when a subscription is present, are sent when the list updates occur.
//       Initial resolution requests use the same lists, so the best way to avoid inconsistency and unnecessary server load is to subscribe
//       and process updates when notified.
message SymbolResolutionRequest
{
	// Symbol pattern to resolve.
	required string symbol = 1;
}

// Symbol resolution result or update.
message SymbolResolutionReport
{
	// Resolved contract meta-data
	required ContractMetadata contract_metadata = 1;
}

// Request for balances from the last statement for all authorized accounts.
message LastStatementBalancesRequest
{
}

// Report with balances from the last statement for all authorized accounts,
// they will be sent as a response to a corresponding request
// and after each statement processing (if subscribed).
message LastStatementBalancesReport
{
	repeated Balance balance = 1;
}

// Balance record for one of the accounts and one of the currencies (id is used as a key for updates).
// Values like OTE, UPL and MVO are from statements and won't be updated in real time but after each next statement.
// Money related values are in the specified currency.
// NOTE: There could be more then one balance for one account and one currency. 
//       Not all values for a balance record are provided by all statements, it is up to Brokerage to include such values and only 
//       currency and ending cash balance are required to be valid.
message Balance
{
	// Surrogate id as a key for updates.
	required sint32 id = 1;

	// Account of this balance record.
	required sint32 account_id = 2;

	// Statement date this positions is related.
	required sint64 statement_date = 3;

	// Currency code (ISO 4217 based).
	required string currency = 4;

	// Ending Cash Balance.
	required double balance = 5;

	// Total Account Value.
	required double total_value = 6;

	// Open Trade Equity for Futures.
	required double ote = 7;

	// Unrealized profit-loss.
	required double upl = 8;

	// Market Value of options.
	required double mvo = 9;

	// Cash Excess.
	required double cash_excess = 10;

	// Collateral on Deposit.
	required double collateral = 11;

	// Initial Margin Requirements.
  	required double initial_margin = 12;
}

// Request for currency rates for all brokerages user's accounts belong to.
message CurrencyRatesRequest
{
}

// Report with currency rates per brokerage.
// It will be sent as a response to a corresponding request
// and after each statement processing (if subscribed).
message CurrencyRatesReport
{
	// List of rates per brokerage the user is authorized to.
	repeated BrokerageCurrencyRates brokerage_currency_rates = 1;
}

// Currency rates of one brokerage.
message BrokerageCurrencyRates
{
	// Brokerage ID.
	required uint32 brokerage_id = 1;

	// Master currency code to which rates are provided (ISO 4217 based).
	required string master_currency = 2;

	// Statement date.
	required sint64 statement_date = 3;

	// List of brokerage rates.
	repeated CurrencyRate currency_rate = 4;
}

// Rate of one currency to a master currency for the brokerage.
message CurrencyRate
{
	// Currency code (ISO 4217 based).
	required string currency = 2;

	// Exchange rate.
	required double rate = 3;
}

// Request for session information per instrument group.
message SessionInformationRequest
{
	// ID of a session information from contract meta-data.
	required sint32 session_info_id = 1;

	// UTC time from which session information is requested (e.g. if historical session times are necessary)
	// Current time is used by default.
	optional sint64 from_utc_time = 2;

	// UTC time up to which session information is requested (e.g. if future session times are necessary)
	// Current time is used by default. This field must not be used with subscriptions.
	optional sint64 to_utc_time = 3;
}

// Report with session information.
message SessionInformationReport
{
	// Session information ID.
	required sint32 session_info_id = 1;

	// List of session segment records.
	repeated SessionSegment session_segment = 2;
}

// Session segment record.
message SessionSegment
{
	// Session segment ID useful for updates.
	required sint32 session_segment_id = 1;

	// Session group is deleted (used for updates).
	optional bool deleted = 2;

	// UTC time from which this session information is effective (inclusive).
	// It is omitted if this session information was the same since Instrument group was introduced.
	optional sint64 from_utc_time = 3;

	// UTC time up to which this session information is effective (exclusive).
	// It is omitted if this session information is not planned yet to be changed.
	optional sint64 to_utc_time = 4;

	// Schedule for all sessions.
	repeated SessionSchedule session_schedule = 5;

	// Trading day schedule.
	repeated TradingDay trading_day = 6;

	// Daily holidays. May have some sessions interday, but daily bar is not created.
	repeated SessionHoliday daily_holiday = 7;
}

// Session schedule.
message SessionSchedule
{
	// Session name.
	required string name = 1;

	// List of session times per day of week.
	repeated SessionDay session_day = 2;

	// List of exchange specific dates when this session is closed.
	repeated SessionHoliday session_holiday = 3;

	// True if this is a primary session.
	optional bool is_primary = 4;
}

// Days of week enumeration. 
enum DayOfWeek
{
	Sunday = 0;
	Monday = 1; 
	Tuesday = 2; 
	Wednesday = 3;
	Thursday = 4;
	Friday = 5;
	Saturday = 6;
}

// Trading day schedule.
message TradingDay
{
	// Days of week list with the same day schedule.
	repeated DayOfWeek day_of_week = 1;

	// Trading day start offset in milliseconds from 00:00 UTC.
	optional sint64 start_offset = 2;
}

// Session times per day of week.
// All time offsets are in milliseconds from 00:00 UTC time of a specific date that corresponds to specific day of week.
// Offset values are optional and can be positive and negative
// (e.g. session can be completely 'pre-open' so only pre_open_offset and post_close_offset values are set).
// NOTE: Session times may not match exact exchange schedule especially if exchange have dynamic times
// (e.g. session starts after publishing a settlement, after underlying contract trade, etc.) 
// or if exchange sends market data outside of session boundaries (e.g. late trades)
message SessionDay
{
	// Days of week list with the same day schedule.
	repeated DayOfWeek day_of_week = 1;

	// Session pre-open time offset.
	optional sint64 pre_open_offset = 2;

	// Session open time offset.
	optional sint64 open_offset = 3;

	// Session close time offset.
	optional sint64 close_offset = 4;

	// Session post-close time offset.
	optional sint64 post_close_offset = 5;
}

// Session holiday record.
message SessionHoliday
{
	// Date of a holiday.
	required sint64 holiday_date = 1;

	// Name of a holiday.
	required string holiday_name = 2;
}


////------------------------------------------
//// Trade Routing messaging


// Subscription to trade routing data and notifications about trading information updates.
// Client can be subscribed to several publications.
// If some account is subscribed by several publications then client will receive a separate snapshot per subscription
// but one real time update with a list of subscriptions.
message TradeSubscription
{
	// ID of a subscription that should be unique enough to match responses and updates with corresponding requests.
	required uint32 id = 1;

	// Scope of the subscription (provide a list).
	enum SubscriptionScope
	{
		// Subscribe to order updates.
		ORDERS = 1;

		// Subscribe to open positions and matched trades updates.
		POSITIONS = 2;

		// Subscribe to collateral updates (current margin and purchasing power).
		COLLATERAL = 3;
	}
	// This field is associated with SubscriptionScope enum type.
	repeated uint32 subscription_scope = 2;

	// Type of the publication to subscribe.
	enum PublicationType
	{
		// Subscribe to a single account.
		ACCOUNT = 1;

		// Subscribe to all accounts of a specific sales series.
		SALES_SERIES = 2;

		// Subscribe to all accounts of a specific brokerage.
		BROKERAGE = 3;

		// Subscribe to all accounts this user is authorized for (default).
		ALL_AUTHORIZED = 4;
	}
	// This field is associated with PublicationType enum type.
	optional uint32 publication_type = 3;

	// Account ID when publicationType = ACCOUNT.
	optional uint32 account_id = 4;

	// Sales series number when publicationType = SALES_SERIES.
	optional string sales_series_number = 5;

	// Brokerage ID when publicationType = BROKERAGE.
	optional uint32 brokerage_id = 6;

	// True to subscribe, false to unsubscribe (only id value is used to unsubscribe).
	required bool subscribe = 7;

	// Optionally limit request to receive information about orders that were updated/ added after specified server related time (inclusive).
	// It is used to reduce amount of information necessary to send after re-connection.
	// Client should set this time equal to the last received order status time ('status_utc_time' field) in UTC to avoid gaps and
	// be ready for duplicates that have to be detected by corresponding IDs.
	optional sint64 last_order_update_utc_time = 8;

	// True means sending only real time data and skip sending an initial orders snapshot, send initial snapshot otherwise.
	// NOTE: do not set this attribute after restoring session since some events might be missed to be delivered,
	// use last_order_update_utc_time instead.
	optional bool skip_orders_snapshot = 9;

	// True means sending only FCM confirmed positions and their updates (if subscribed)
	// without matching with current day fills, send matched net positions otherwise.
	optional bool confirmed_positions_only = 10;

	// Positions matching algorithm (for position subscription).
	enum MatchingAlgorithm
	{
		// First In, First Out. The first order filled is the first order offset when an order on the opposite side of the market is executed.
		FIFO = 1;

		// High Buy, High Sell. The highest buy is matched with the highest sell.
		HBHS = 2;

		// Last In, First Out. The last order filled is the first order offset when an order on the opposite side of the market is executed.
		LIFO = 3;
	}
	// This field is associated with MatchingAlgorithm enum type.
	// FIFO is used if omitted.
	optional uint32 matching_algorithm = 11;

	// If true or omitted then intraday trades are matched first and then intraday leftover is matched against previous close positions.
	// If false then previous day open positions and intraday fills are matched in a single pass.
	optional bool match_intraday_first = 12;

	// This field is associated with MatchingAlgorithm enum type.
	// Historical positions Matching algorithm. The same as matching_algorithm if omitted.
	// It is ignored if match_intraday_first is false.
	optional uint32 historical_matching_algorithm = 13;

}

// Server status for a trade subscription.
// It is sent before or along with a snapshot of initial status information.
message TradeSubscriptionStatus
{
	// Subscription Id this result is sent for.
	required uint32 id = 1;

	// Possible result codes.
	enum StatusCode
	{
		// success codes (0 - 99)
		SUCCESS = 0;

		// Currently subscription is [partially] disconnect because of communication issues
		// NOTE: Clients should not resubscribe in this case, the server will restore subscription with 
		// sending SUCCESS status once communication issues are resolved following with all necessary data updates
		DISCONNECTED = 1;

		// failure codes (100+)
		FAILURE = 101;
	}
	// Subscription result.
	// This field is associated with StatusCode enum type.
	required uint32 status_code = 2;

	// Optional details.
	optional string text_message = 3;
}

// Indicator that a snapshot of requested information is delivered and corresponding data is complete.
message TradeSnapshotCompletion
{
	// ID of a corresponding trade subscription.
	required uint32 subscription_id = 1;

	// List of subscription scopes whose snapshots are completed.
	// Completion message for one scope is sent only once but they can be combined
	// (e.g. one completion message might come for ORDERS and another one later for POSITIONS and COLLATERAL).
	// This field is associated with TradeSubscription.SubscriptionScope enum type.
	repeated uint32 subscription_scope = 2;
}

// One of the order related requests. There must be only one optional field specified per request.
message OrderRequest
{
	// ID of a request that should be unique enough to match with possible OrderRequestReject.
	required uint32 request_id = 1;

	// New order request (place order).
	optional NewOrder new_order = 2;

	// Modify order request.
	optional ModifyOrder modify_order = 3;

	// Cancel order request.
	optional CancelOrder cancel_order = 4;

	// Activate suspended order.
	optional ActivateOrder activate_order = 5;

	// Modify order's user attributes.
	optional ModifyUserAttributes modify_user_attributes = 6;

	// Username of the user on whose behalf the order request is being sent.
	optional string on_behalf_of_user = 7;

	// New compound order request (place compound order).
	optional NewCompoundOrder new_compound_order = 8;
	
	// Regulatory Algorithm ID for client algorithm associated with this order, if any.
	// This field is applicable only for exchanges that use it, e.g. Eurex.
	// TransactionStatus message echoes back the value from the latest order request
	optional uint32 client_regulatory_algorithm_id = 9;
}

// Low-level order request reject. It is sent only if direct order status updates are impossible.
message OrderRequestReject
{
	// ID of the order request this reject corresponds to.
	required uint32 request_id = 1;

	// Reject code. The list is provided separately.
	required uint32 reject_code = 2;

	// Optional reject details message.
	optional string text_message = 3;
}

// New order request.
message NewOrder
{
	// Order to place.
	required Order order = 1;

	// True if order should be suspended and wait a separate activate request or activation time.
	optional bool suspend = 2;
}

// Trade routing order. It is used as new order request and as a part of order status updates.
message Order
{
	enum Side
	{
		// Describes purchasing side of a trade.
		BUY = 1;

		// Describes selling side of a trade.
		SELL = 2;
	}

	enum OrderType
	{
		// Market order, buy or sell by the best available opposite price.
		MKT = 1;

		// Limit order, buy or sell by price that is the same or better then specified limit price.
		LMT = 2;

		// Stop order, Order becomes a Market when market reaches order's stop price
		// (which is on opposite side of market).
		STP = 3;

		// Stop-limit order, Order becomes a Limit when market reaches order's stop price.
		STL = 4;
	}

	enum ExecInstruction
	{
		// All or None (fill order only completely).
		AON = 1;

		// Iceberg (show only part of order size).
		ICEBERG = 2;

		// Quantity triggered (aka DOM Triggered, honor additional quantity threshold for triggering).
		QT = 3;

		// Trailing order (price of the order is following market one direction by specific offset).
		TRAIL = 4;

		// Funari (Limit order becomes a Market on Close).
		FUNARI = 5;

		// Market if Touched (Limit order becomes a Market when market reaches order's limit price).
		MIT = 6;

		// Market Limit Market is a limit order that is used to place a buy order above the best offer 
		// to fill by the best offer or a sell order below the best bid to fill by the best bid.
		MLM = 7;
	}

	enum Duration
	{
		// Day order. Order is working through the current trading day only.
		DAY = 1;

		// Good Til Canceled. Order is working until canceled or until the contract is no longer available for trading.
		GTC = 2;

		// Good Til Date. Order is working until the end of the nearest trading day for the contract on 
		// or before the date specified in the order.
		GTD = 3;

		// Good Til Time. Order is working until the specified time.
		GTT = 4;

		// Fill and Kill. Immediately fill as many as possible and cancel the rest.
		FAK = 5;

		// Fill Or Kill. Immediately fill this order completely or cancel.
		FOK = 6;

		// At The Open. Buy or sell at the very beginning of the trading day.
		ATO = 7;

		// At The Close. Buy or sell at the close of the market, or as near to the closing price as possible.
		ATC = 8;
	}

	enum TrailingPeg
	{
		// Trail the best bid.
		BESTBID = 1;

		// Trail the best ask.
		BESTASK = 2;

		// Trail the last trade.
		LASTTRADE = 3;
	}

	// Id of an account that is/ was used to place an order.
	required sint32 account_id = 1;

	// Client side time when an order was submitted (UTC).
	required sint64 when_utc_time = 2;

	// Server side contract Id of the order (see ContractMetadata message).
	required uint32 contract_id = 3;

	// Client order identifier, must be unique within a single trading day for day orders and across days for multi-day orders.
	required string cl_order_id = 4;

	// Order type.
	// This field is associated with OrderType enum type.
	required uint32 order_type = 5;

	// List of applicable execution instructions.
	// This field is associated with ExecInstruction enum type.
	repeated uint32 exec_instruction = 6;

	// Order duration.
	// This field is associated with Duration enum type.
	required uint32 duration = 7;

	// Date for GTD (local to exchange, date only value in time format) when the order should expire.
	optional sint64 good_thru_date = 8;

	// Order side.
	// This field is associated with Side enum type.
	required uint32 side = 9;

	// Limit price of the order (required for Limit and Stop-limit orders).
	optional sint32 limit_price = 10;

	// Stop price of the order (required for Stop and Stop-limit orders).
	optional sint32 stop_price = 11;

	// Total positive size of the order.
	required uint32 qty = 12;

	// Visible size of the order for Icebergs.
	optional uint32 visible_qty = 13;

	// Minimum visible positive size of the order
	// used for iceberg orders with 'random visible size',
	// must be < visible_qty.
	optional uint32 min_visible_qty = 14;

	// True if this is a manual order (order placed by the user direct action), automated otherwise.
	required bool is_manual = 15;

	// True if order is used for closing/ reducing a position, opening/ increasing otherwise
	// (omit this field if there is no need to be explicit).
	optional bool is_close = 16;

	// True if the order is aggressive (Fixed Income specific order modifier).
	optional bool is_aggressive = 17;

	// Maximum offset between market and limit prices for trail orders.
	optional sint32 trail_offset = 18;

	// Trailing limit peg to follow specific side of the market.
	// This field is associated with TrailingPeg enum type.
	optional uint32 trailing_peg = 19;

	// Trigger quantity (threshold) as additional stop order activation condition.
	optional uint32 trigger_qty = 20;

	// Time when order should be submitted to execution system as assigned by client (UTC).
	optional sint64 activation_utc_time = 21;

	// Time when order should be suspended (UTC).
	optional sint64 suspension_utc_time = 22;

	// User specific attributes.
	repeated UserAttribute user_attribute = 23;

	// Date and time for GTT order (UTC) when the order should expire.
	optional sint64 good_thru_utc_time = 24;
}

// User defined attribute.
message UserAttribute
{
	// Attribute name.
	required string name = 1;

	// Attribute value (optional for modification if attribute is deleted).
	optional string value = 2;

	// True if attribute has to be deleted during modify operation.
	optional bool delete = 3;
}

// Modify order request, include only fields that are supposed to be modified.
message ModifyOrder
{
	// Order id assigned by server after last modification.
	required string order_id = 1;

	// ID of the order's account.
	required sint32 account_id = 2;

	// This client order ID of the order to modify.
	required string orig_cl_order_id = 3;

	// Client order ID of this modify request (will become new client order Id if modify is accepted).
	required string cl_order_id = 4;

	// Client side time when a modify request was submitted (UTC).
	required sint64 when_utc_time = 5;

	// Order size what the client wants the total size to become.
	optional uint32 qty = 6;

	// What the client wants the visible size to become.
	optional uint32 visible_qty = 7;

	// What the client wants the minimum visible size to become.
	optional uint32 min_visible_qty = 8;

	// What the client wants the limit price to become.
	optional sint32 limit_price = 9;

	// What the client wants the stop price to become.
	optional sint32 stop_price = 10;

	// What the client wants the activation time to become (UTC).
	optional sint64 activation_utc_time = 11;

	// True if activation time should be removed.
	optional bool remove_activation_time = 12;

	// What the client wants the suspension time to become (UTC).
	optional sint64 suspension_utc_time = 13;

	// True if suspension time should be removed.
	optional bool remove_suspension_utc_time = 14;

	// What the client wants the order duration to become.
	// This field is associated with Order.Duration enum type.
	optional uint32 duration = 15;

	// What the client wants the order expiration date to become (see Order.good_thru_date).
	optional sint64 good_thru_date = 16;

	// What the client wants the order expiration time to become (see Order.good_thru_utc_time).
	optional sint64 good_thru_utc_time = 17;
}

// Cancel order request.
message CancelOrder
{
	// Order id assigned by server after last modification.
	required string order_id = 1;

	// ID of the order's account.
	required sint32 account_id = 2;

	// This client order ID of the order to cancel.
	required string orig_cl_order_id = 3;

	// Client order ID of this cancel request.
	required string cl_order_id = 4;

	// Client side time when a modify request was submitted (UTC).
	required sint64 when_utc_time = 5;
}

// Activate suspended order request.
message ActivateOrder
{
	// Order id assigned by server after last modification.
	required string order_id = 1;

	// ID of the order's account.
	required sint32 account_id = 2;

	// This client order ID of the order to activate.
	required string orig_cl_order_id = 3;

	// Client order ID of this activation request (will become new client order Id if activation is accepted).
	required string cl_order_id = 4;

	// Client side time when a modify request was submitted (UTC).
	required sint64 when_utc_time = 5;
}

// Modification of order's user attributes.
message ModifyUserAttributes
{
	// ID of the order chain.
	required string chain_order_id = 1;

	// ID of the order's account.
	required sint32 account_id = 2;

	// List of attributes to modify.
	repeated UserAttribute user_attribute = 3;
}

// Placement of a compound order.
message NewCompoundOrder
{
	// Compound order to place.
	required CompoundOrder compound_order = 1;

	// Indicates whether compound order execution shall happen on a partial fill (true or omitted) 
	// or complete fill (false).
	optional bool partial_fills_handling = 2 [default = true];
}

// Compound order.
message CompoundOrder
{
	// Type of the compound order.
	enum Type
	{
		// Order Places Order.
		// [Partial] fill of the first entry triggers [partial] placement of all other orders.
		OPO = 1;

		// Order Cancels Order. This type allows several compound order entires.
		// [Partial] fill of any order triggers [partial] canceling of all other orders.
		OCO = 2;
	}
	// This field is associated with Type enum type.
	required uint32 type = 1;

	// ID of the compound order assigned by client.
	required string cl_compound_id = 2;

	// List of entires.
	repeated CompoundOrderEntry compound_order_entry = 3;
}

// Entry of a compound order. Only one of optional fields has to be specified.
message CompoundOrderEntry
{
	// Regular order entry.
	optional Order order = 1;

	// Sub-compound order entry.
	optional CompoundOrder compound_order = 2;
}

// Status of order.
message OrderStatus
{
	// List of trade subscription IDs this status is related to.
	repeated uint32 subscription_id = 1;

	// True if this is a snapshot related message.
	// Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
	// an indicator of complete snapshot delivery for a particular subscription.
	optional bool is_snapshot = 2;

	// Current order status.
	enum Status
	{
		// Original order is sent to execution system.
		IN_TRANSIT = 1;

		// Order is rejected.
		REJECTED = 2;

		// Order is acknowledged by execution and perhaps partially filled.
		WORKING = 3;

		// Order is expired.
		EXPIRED = 4;

		// Cancel request is sent to execution system.
		IN_CANCEL = 5;

		// Modify request is sent to execution system.
		IN_MODIFY = 6;

		// Order is canceled.
		CANCELLED = 7;

		// Order is completely filled by execution system.
		FILLED = 8;

		// Order is waiting submission to execution system.
		SUSPENDED = 9;

		// Order may be canceled because a disconnect occurred.
		DISCONNECTED = 10;

		// Order will be placed at a specified time (waiting execution system to start accepting orders).
		ACTIVEAT = 11;
	}
	// This field is associated with Status enum type.
	required uint32 status = 3;

	// Order ID assigned by server.
	// It is changed by server after each modify request acknowledgment.
	required string order_id = 4;

	// Order ID assigned by server to originally placed order. It stays the same regardless of modification requests.
	required string chain_order_id = 5;

	// Order ID assigned by execution system (e.g. exchange).
	optional string exec_order_id = 6;

	// Last order change time from server perspective (UTC).
	required sint64 status_utc_time = 7;

	// Time when original order was submitted to the execution system by server (UTC).
	required sint64 submission_utc_time = 8;

	// Filled quantity.
	required uint32 fill_qty = 9;

	// Number of fill events.
	required uint32 fill_cnt = 10;

	// Average fill price.
	// NOTE: this price is aligned by a tick size so don't use it for OTE/UPL calculation but
	// use prices from individual TRADE elements.
	required sint32 avg_fill_price = 11;

	// Time when order should be submitted to execution system as assigned by server (UTC).
	optional sint64 active_at_utc_time = 12;

	// Remaining (unfilled) order quantity. It is not always equal
	// to order size minus filled size (for example, busted orders violate that).
	required uint32 remaining_qty = 13;

	// order with updated attributes. server may not send it if order attributes remained the same since last update
	optional Order order = 14;

	// List of [last] transactions. In case of initial snapshot (if last_orders_update_utc_time was not set in TradeSubscription)
	// all available transactions are sent. This list can be empty if this status is sent to update order attributes only
	// (e.g. to update prices of trailing orders).
	repeated TransactionStatus transaction_status = 15;

	// User who placed the order, or user on whose behalf the order was placed.
	required string entered_by_user = 16;

	// Statement date when this order was submitted.
	required sint64 first_statement_date = 17;

	// Last statement date this order belongs to. It is set when order is cleaned by a statement report
	// so that order is not 'current' any longer.
	optional sint64 last_statement_date = 18;

	// List of contract meta-data for contracts that are unknown to the client before this status update.
	repeated ContractMetadata contract_metadata = 19;

	// Id of an account for this order status.
	required sint32 account_id = 20;

	// If the order is part of a compound order then this field describe the structure of the compound.
	optional CompoundOrderStructure compound_order_structure = 21;
}

// Status of a specific transaction.
// All attributes are at the transaction moment.
message TransactionStatus
{
	// Status of the transaction.
	enum Status
	{
		// Original order is sent to execution system.
		IN_TRANSIT = 1;

		// Original order is rejected (exception).
		REJECTED = 2;

		// Order is acknowledged by execution system.
		ACK_PLACE = 3;

		// Order is expired (exception).
		EXPIRED = 4;

		// Cancel request is sent to execution system.
		IN_CANCEL = 5;

		// Cancel is acknowledged by execution system.
		ACK_CANCEL = 6;

		// Cancel request is rejected (exception).
		REJECT_CANCEL = 7;

		// Modify request is sent to execution system.
		IN_MODIFY = 8;

		// Modify is acknowledged by execution system.
		ACK_MODIFY = 9;

		// Modify request is rejected (exception).
		REJECT_MODIFY = 10;

		// Fill event is received from execution system.
		FILL = 11;

		// Order is suspended.
		SUSPEND = 12;

		// Referenced fill is corrected.
		FILL_CORRECT = 13;

		// Referenced fill is canceled (exception).
		FILL_CANCEL = 14;

		// Referenced fill is busted (exception).
		FILL_BUST = 15;

		// Acknowledgment that order will activate at specified time.
		ACTIVEAT = 16;

		// Order may be canceled because a disconnect occurred (exception).
		DISCONNECT = 17;

		// Synthetic order was sent to the actual execution system.
		SYNTHETIC_ACTIVATED = 18;

		// Order status and/ or attributes are updated.
		UPDATE = 19;
	}
	// This field is associated with Status enum type.
	required uint32 status = 1;

	// Order transaction identifier, unique within order chain.
	required uint64 trans_id = 2;

	// Transaction time assigned by server (UTC).
	required sint64 trans_utc_time = 3;

	// Reference transaction ID to the previous fill transaction for a bust, cancel or correction.
	optional uint64 ref_trans_id = 4;

	// If order is modified, this client order ID of the order before modification.
	optional string orig_cl_order_id = 5;

	// Client order ID of the order at the transaction moment.
	required string cl_order_id = 6;

	// Filled quantity for fill transactions or updated quantity for fill correction.
	optional uint32 fill_qty = 7;

	// Fill price for fill transactions or updated price for fill correction.
	optional sint32 fill_price = 8;

	// List of specific per leg trades (more than one for strategies).
	repeated Trade trade = 9;

	// If order is modified, this is the previous order size.
	optional uint32 prev_order_qty = 10;

	// If order is modified, this is the updated order size.
	optional uint32 order_qty = 11;

	// If order is modified, this is the previous order limit price.
	optional sint32 prev_limit_price = 12;

	// If order is modified, this is the updated order limit price.
	optional sint32 limit_price = 13;

	// If order is modified, this is the previous order stop price.
	optional sint32 prev_stop_price = 14;

	// If order is modified, this is the updated order stop price.
	optional sint32 stop_price = 15;

	// If order is modified, this is the previous visible order size.
	optional uint32 prev_visible_qty = 16;

	// If order is modified, this is the updated visible order size.
	optional uint32 visible_qty = 17;

	// If order is modified, this is the previous min visible order size.
	optional uint32 prev_min_visible_qty = 18;

	// If order is modified, this is the updated min visible order size.
	optional uint32 min_visible_qty = 19;

	// If fill is modified, the previous size is reported here.
	optional uint32 prev_fill_qty = 20;

	// If fill is modified, the previous price is reported here.
	optional sint32 prev_fill_price = 21;

	// If order is modified, this is the previous order type.
	// This field is associated with Order.OrderType enum type.
	optional uint32 prev_order_type = 22;

	// If order is modified, this is the updated order type.
	// This field is associated with Order.OrderType enum type.
	optional uint32 order_type = 23;

	// If order is modified, these are the previous exec instructions.
	// This field is associated with Order.ExecInstruction enum type.
	repeated uint32 prev_exec_instruction = 24;

	// If order is modified, these are the updated exec instructions.
	// This field is associated with Order.ExecInstruction enum type.
	repeated uint32 exec_instruction = 25;

	// If order is modified, this is the previous duration.
	// This field is associated with Order.Duration enum type.
	optional uint32 prev_duration = 26;

	// If order is modified, this is the new duration.
	// This field is associated with Order.Duration enum type.
	optional uint32 duration = 27;

	// If order is modified, this is the previous date then the order should expire  (see Order.good_thru_date).
	optional sint64 prev_good_thru_date = 28;

	// If order is modified, this is the updated date then the order should expire  (see Order.good_thru_date).
	optional sint64 good_thru_date = 29;

	// If order request is rejected, this is rejection code (the list is provided separately).
	optional uint32 reject_code = 30;

	// If present, identifies the counterpart of the order fill, as reported by the execution system.
	optional string fill_counterparty = 31;

	// Order identifier assigned by server when sending the order to execution system.
	optional string route_cl_order_id = 32;

	// Additional transaction details.
	optional string text_message = 33;

	// If order is modified, this is the previous time then the order should expire  (see Order.good_thru_utc_time).
	optional sint64 prev_good_thru_utc_time = 34;

	// If order is modified, this is the updated time then the order should expire  (see Order.good_thru_utc).
	optional sint64 good_thru_utc_time = 35;
	
	// OrderRequest.client_regulatory_algorithm_id value echoed back from the latest order request. 
	optional uint32 client_regulatory_algorithm_id = 36;
	
	// Regulatory Algorithm ID actually sent to the exchange for this order, if any. 
	// Will differ from client_regulatory_algorithm_id if any CQG algorithm was applied to the order.
	optional uint32 effective_regulatory_algorithm_id = 37;
}

// Trade per specific outright contract.
message Trade
{
	// Trade ID assigned by server, unique within account.
	required string trade_id = 1;

	// Server contract identifier.
	required uint32 contract_id = 2;

	// Brokerage statement date this trade corresponds to (in time format, convert to date only).
	required sint64 statement_date = 3;

	// Time of the trade (UTC).
	required sint64 trade_utc_time = 4;

	// Exchange trade day this trade corresponds to (in time format, date only value).
	required sint64 trade_date = 5;

	// Trade price.
	required sint32 price = 6;

	// Trade side.
	// This field is associated with Order.Side enum type.
	required uint32 side = 7;

	// Trade size.
	required uint32 qty = 8;

	// If present, identifies the counter-party of the trade, as reported by the execution system
	// (may or may not match counter-party reported for the order fill).
	optional string trade_counterparty = 9;

	// Flag that trade was made as aggressive.
	optional bool is_aggressive = 10;
}

// Compound order structure.
message CompoundOrderStructure
{
	// This field is associated with CompoundOrder.Type enum type.
	// Type of the compound order.
	required uint32 type = 1;

	// ID of the compound order assigned by client.
	required string cl_compound_id = 2;

	// List of entires.
	repeated CompoundOrderStructureEntry compound_order_entry = 3;
}

// Entry of a compound order structure. One of optional fields is specified.
message CompoundOrderStructureEntry
{
	// Regular order id as assigned by server.
	optional string chain_order_id = 1;

	// Sub-compound order structure entry.
	optional CompoundOrderStructure compound_order_structure = 2;
}

// Status of a contract open positions and purchase and sales for a specific account for the current day
// (contractId and accountId are used as a key for updates).
// Contract position is deleted when all open positions and purchase and sales groups are deleted.
message PositionStatus
{
	// List of trade subscription IDs this status is related to.
	repeated uint32 subscription_id = 1;

	// True if this is a snapshot related message.
	// Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
	// an indicator of complete snapshot delivery.
	optional bool is_snapshot = 2;

	// Account this position belongs to.
	required sint32 account_id = 3;

	// Contract ID assigned by server.
	required uint32 contract_id = 4;

	// True if open positions are short (result of sell operations), long otherwise.
	required bool is_short_open_position = 5;

	// List of new/ updated or deleted open positions.
	// NOTE: full list is sent only in a snapshot, updates include only added, changed and deleted records.
	repeated OpenPosition open_position = 6;

	// List of purchase and sales groups. This group represent offset trades (usually one sell and one buy)
	// NOTE: full list is sent only in a snapshot, updates include only added, changed and deleted records.
	repeated PurchaseAndSalesGroup purchase_and_sales_group = 7;

	// If the contract is new for client then server includes contract meta-data.
	optional ContractMetadata contract_metadata = 8;
}

// Account and contract open position.
// There could be more than one position per account and contract.
// (id is used as a key for updates).
message OpenPosition
{
	// Surrogate id as a key for updates.
	required sint32 id = 1;

	// Position size, zero means that this position is deleted.
	required uint32 qty = 2;

	// Position average price.
	// NOTE: Since it could be an aggregated position price is sent in correct format directly.
	required double price = 3;

	// Exchange specific trade date when the position was open or last changed (date only value).
	required sint64 trade_date = 4;

	// Statement date (date value only).
	required sint64 statement_date = 5;

	// UTC trade time (including date) if available, it might not be available e.g. for the previous day positions
	optional sint64 trade_utc_time = 6;
}

// Purchase and sales group that represents offset trades (usually one sell and one buy trade)
message PurchaseAndSalesGroup
{
	// Surrogate id as a key for updates.
	required sint32 id = 1;

	// Profit/ loss (in contract currency) of the group.
	required double realized_profit_loss = 2;

	// list of matched trades in a group
	// in case of group updates the whole list is sent
	repeated MatchedTrade matched_trade = 3;
}


// Specific trade or position that is a part of a purchase and sales group.
// (id is used as a key for updates).
message MatchedTrade
{
	// Matched size.
	// Zero means matched trade is deleted.
	required uint32 qty = 1;

	// True if this is a short trade (e.g. result of sell operation), long otherwise.
	optional bool is_short = 2;

	// Trade or position average price.
	// NOTE: Since it could be an aggregated position price is sent in correct format directly.
	required double price = 3;

	// Trade date (date value only).
	required sint64 trade_date = 4;

	// Statement date (date value only).
	required sint64 statement_date = 5;

	// UTC trade time (including date) if available, it might not be available e.g. for the previous day positions
	optional sint64 trade_utc_time = 6;
}

// Status of the collateral for a specific account.
// An update is sent once it is changed, updates might be consolidated in case of frequent changes.
message CollateralStatus
{
	// List of trade subscription IDs this status is related to.
	repeated uint32 subscription_id = 1;

	// True if this is a snapshot related message.
	// Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
	// an indicator of complete snapshot delivery for a particular subscription.
	optional bool is_snapshot = 2;

	// Account id of this status.
	required sint32 account_id = 3;

	// Currency code of margin and PP values (ISO 4217 based).
	required string currency = 4;

	// Current total margin.
	required double total_margin = 5;

	// Available account funds including balance, realized profit (or loss), collateral and credits.
	// OTE and MVO are included regarding the account risk parameters.
	required double purchasing_power = 6;
	
	// Open trade equity, or potential profit (or loss) from futures and future-style options positions 
	// based on opening price of the position and the current future trade/best bid/best ask 
	// (regarding to the risk account settings) or settlement price if trade is not available.
	// Included if purchasing power depends on it.
	optional double ote = 7;
	
	// Market value of options calculated as the current market trade/best bid/best ask of the option 
	// (regarding to the risk account settings) times the number of options 
	// (positive for long options and negative for short options) in the portfolio.
	// Included if purchasing power depends on it.
	optional double mvo = 8;
}

////------------------------------------------
//// Market Data messaging

// Subscription to market data.
// If it is necessary to change subscription level client should send a new subscription request with the same ID 
// but a new subscription level.
message MarketDataSubscription
{
	// Level or subscription, each new level is a promotion of the previous one.
	enum Level
	{
		// Unsubscribe.
		NONE = 0;

		// Get trade and settlement quotes.
		TRADES = 1;

		// Get trades, settlement and best ask & bid without volumes.
		TRADES_BBA = 2;

		// Get trades, settlement and best ask & bid with volumes.
		TRADES_BBA_VOLUMES = 3;

		// All price data including DOM.
		TRADES_BBA_DOM = 4;
	}

	// Contract ID to subscribe (see symbol resolution report).
	// This is client's responsibility to re-subscribe in case of symbol resolution update.
	required uint32 contract_id = 1;

	// Subscription level.
	// This field is associated with Level enum type.
	required uint32 level = 2;
}

// Subscription status
message MarketDataSubscriptionStatus
{
	enum StatusCode
	{
		/// success codes (0 - 99)
		SUCCESS = 0;

		// Currently subscription is disconnected because of communication issues
		// NOTE: Clients should not resubscribe in this case, the server will restore subscription with 
		// sending SUCCESS status once communication issues are resolved
		DISCONNECTED = 1;

		/// failure codes (100+)
		// general failure
		FAILURE = 101;

		// Subscription parameters are invalid.
		INVALID_PARAMS = 102;

		// The user is not allowed to be subscribed to this Instrument.
		ACCESS_DENIED = 103;

		// Market data source was deleted because of expiration or by another reason.
		DELETED = 104;
	}

	// Subscription contract ID.
	required uint32 contract_id = 1;

	// Subscription result.
	// This field is associated with StatusCode enum type.
	required uint32 status_code = 2;

	// Effective subscription level.
	// This field is associated with MarketDataSubscription.Level enum type.
	required uint32 level = 3;

	// Possible details of subscription failure.
	optional string text_message = 4;
}

// Real time data delivery.
// Snapshot is sent as the first message after subscription and may appear periodically when subscribed.
message RealTimeMarketData
{
	// Contract ID assigned by server.
	required uint32 contract_id = 1;

	// Contract quotes. DOM is updated by new volumes per price. zero volume is used to clean this price record from DOM
	repeated Quote quote = 2;

	// True if this is a snapshot (all previously known quotes about this contract should be cleaned).
	optional bool is_snapshot = 3;

	// Collapsing level that was applied by server.
	// NONE if the field is omitted.
	// This field is associated with RealTimeCollapsing.Level enum type.
	optional uint32 collapsing_level = 4;

	// Market values of a contract (e.g. Open/High/Low/Close).
	// Present in snapshots and in updates if some values are changed (only changed values are included in updates).
	optional MarketValues market_values = 5;
}

// Specific quote information
message Quote
{
	// Type of the quote.
	enum Type
	{
		// Trade quote.
		TRADE = 0;

		// Best bid quote.
		BESTBID = 1;

		// Best ask quote.
		BESTASK = 2;

		// Bid quote (DOM level).
		BID = 3;

		// Ask quote (DOM level).
		ASK = 4;

		// Settlement quote.
		SETTLEMENT = 5;
	}
	// This field is associated with Type enum type.
	required uint32 type = 1;

	// Time of the quote (UTC).
	// It is set only if time of this quote is different from the previous one in the list of quotes.
	optional sint64 quote_utc_time = 2;

	// Quote price.
	required sint32 price = 3;

	// Quote volume (included for BBA only if volume is subscribed).
	optional uint64 volume = 4;

	// Optional indicator(s) that this quote also updates some of Open/High/Low/Close session prices.
	enum SessionOhlcIndicator
	{
		// Price of this quote is a new open price of the contract session.
		OPEN = 1;

		// Price of this quote is a new high price of the contract session.
		HIGH = 2;

		// Price of this quote is a new low price of the contract session.
		LOW = 3;

		// Price of this quote is a new close price of the contract session.
		CLOSE = 4;
	}
	// This field is associated with SessionOhlcIndicator enum type.
	repeated uint32 session_ohlc_indicator = 5;
}

// Market data values of a contract.
message MarketValues
{
	// Open price.
	optional sint32 open_price = 1;

	// High price.
	optional sint32 high_price = 2;

	// Low price.
	optional sint32 low_price = 3;

	// Close price.
	optional sint32 close_price = 4;

	// Yesterday settlement price.
	optional sint32 yesterday_settlement = 5;

	// Today contract total volume.
	optional uint32 total_volume = 6;

	// Yesterday close price.
	optional sint32 yesterday_close = 7;

	// Indicative open price.
	optional sint32 indicative_open = 8;
}

// Read stored user attribute by name.
message ReadUserAttributeRequest
{
	// ID of a request and optional subscription that should be unique enough to match responses and updates with corresponding requests.
	required uint32 request_id = 1;

	// List of names of requested attributes or expressions to match.
	// Empty list means requesting of all available user attributes
	repeated string attribute_name = 2;
}

// Result with requested attributes.
message ReadUserAttributeResult
{
	// Corresponding request ID
	required uint32 request_id = 1;

	// Result code.
	enum ResultCode
	{
		// success codes
		SUCCESS = 0;

		// failure codes (100+)
		FAILURE = 101;
	}
	// This field is associated with ResultCode enum type.
	required uint32 result_code = 2;

	// List of requested attributes.
	repeated UserAttribute user_attribute = 3;

	// Optional failure details.
	optional string text_message = 4;
}

// Modify or delete user attributes.
message ModifyUserAttributeRequest
{
	// ID of a request that should be unique enough to match responses with corresponding requests.
	required uint32 request_id = 1;

	// List of attributes to modify.
	repeated UserAttribute user_attribute = 2;
}

// User attributes modification result.
message ModifyUserAttributeResult
{
	// Corresponding request ID.
	required uint32 request_id = 1;

	// Result code.
	enum ResultCode
	{
		// success codes
		SUCCESS = 0;

		// failure codes (100+)
		FAILURE = 101;
	}
	// This field is associated with ResultCode enum type.
	required uint32 result_code = 2;

	// Optional failure details.
	optional string text_message = 3;
}

// Parameters for Time and Sales request.
message TimeAndSalesParameters
{
	// contract id for Time and Sales request.
	required uint32 contract_id = 1;

	// Level or requested Time and Sales data.
	enum Level
	{
		// Get trades with volumes and settlement quotes.
		TRADES = 1;

		// Get trades, settlement and best ask & bid quotes with volumes.
		TRADES_BBA_VOLUMES = 3;
	}
	// This field is associated with Level enum type.
	required uint32 level = 2;

	// Time and Sales period time to start from.
	required sint64 from_utc_time = 3;

	// Optional Time and Sales period finish time.
	// Current server time is used if it is not specified.
	optional sint64 to_utc_time = 4;
}


// Time and sales request (30 days history limit).
message TimeAndSalesRequest
{
	// Request ID, should be unique among currently processed requests.
	required uint32 request_id = 1;

	// parameters of a request, ignored for a DROP operation.
	optional TimeAndSalesParameters time_and_sales_parameters = 2;

	// Type of request.
	enum RequestType
	{
		// Request.
		GET = 1;
	
		// Drop request.
		DROP = 3;
	}
	// This field is associated with RequestType enum type. GET operation is processed by default.
	optional uint32 request_type = 3;
}

message TimeAndSalesReport
{
	// ID of a corresponding request.
	required uint32 request_id = 1;

	// Result code.
	enum ResultCode
	{
		/// success codes  (0 - 99)
		// Request is processed successfully.
		SUCCESS = 0;

		// Delayed request is dropped by a client.
		DROPPED = 2;

		// Request processing status that indicates that currently processing is impossible because of communication issues.
		// NOTE: Clients should not resend requests in this case, the server will restore processing with 
		// sending SUCCESS status once communication issues are resolved.
		// If client is not interested in this request any longer it should send DROP request.
		DISCONNECTED = 4;

		/// failure codes (100+)
		// General failure.
		FAILURE = 101;

		// The user is not allowed to access this instrument data.
		ACCESS_DENIED = 103;

		// Requested information is not found.
		NOT_FOUND = 104; 

		// Requested data is outside of allowed range.
		OUTSIDE_ALLOWED_RANGE = 105;
	}
	// This field is associated with ResultCode enum type.
	required uint32 result_code = 2;

	// List of the requested Time and Sales as quotes.
	// Note that in order to simplify linking of T&S with real time quotes by a client server will atomically include
	// all quotes with the same time-stamp into T&S without splitting the group.
	repeated Quote quote = 3;

	// Time up to which the quotes were included into this report,
	// if there were several with the same time-stamp equal to this time then all are included into the report (UTC).
	// This time is set only for for 'up-to-current' requests.
	optional int64 up_to_utc_time  = 4;

	// True means that requested data is complete at the moment, false means more report messages are expected for completeness.
	optional bool is_report_complete = 5 [default = true];

	// Optional failure details.
	optional string text_message = 6;

	// Request contains dates partially outside of allowed historical data depth.
	optional bool truncated = 7;
}

// Parameters of a time bar request.
message TimeBarParameters
{
	// Contract id for a bar request.
	required uint32 contract_id = 1;

	// Bar unit type.
	enum BarUnit
	{
		/// Multi-day bars (3 year history limit).

		// yearly bars
		YEAR = 1;

		// semi-annual bars
		SEMI_ANNUAL = 2;

		// quarterly bars
		QUARTER = 3;

		// monthly bars
		MONTH = 4;

		// weekly bars
		WEEK = 5;

		// daily bars
		DAY = 6;

		/// Intra-day bars (3 month history limit).

		// hourly bars
		HOUR = 7;

		// minute bars
		MIN = 8;

	}
	// This field is associated with BarUnit enum type.
	required uint32 bar_unit = 2;

	// Number of units per a single bar for Intra-day bars (must be within 24 hours period).
	optional uint32 units_number = 3;

	// Bars period time to start from.
	required sint64 from_utc_time = 4;

	// Optional bars period finish time.
	// Current server time is used if it is not specified.
	optional sint64 to_utc_time = 5;
	
	// Defines content of the close_price and settlement_price fields in TimeBar.
	// close_price is set to last price if the use_settlements is false or omitted, settlement_price is omitted.
	// settlement_price is set to trade date's settlement price (or omitted for today's bar, if contract did not yet settle) if the use_settlements is true, close_price is omitted.
	optional bool use_settlements = 6;
}

// Request for time bars with optional subscription.
// Number of simultaneous bar update subscriptions is limited, 50 by default.
// In case of subscription updates are sent when a bar opens, closes or when it is corrected. Corrected bars are sent even
// if they are outside of requested time bounds. Range can be expanded with another request if needed.
// Bar also is updated upon expiration the update interval (1 second for Intra-day bars or 1 minute for Inter-day bars), if changed.
message TimeBarRequest
{
	// request or subscription ID
	required uint32 request_id = 1;

	// parameters of a request, ignored for a DROP operation.
	optional TimeBarParameters time_bar_parameters = 2;

	// Type of a bar request.
	enum RequestType
	{
		// Request bars without subscription.
		GET = 1;

		// Request bars with subscription for updates.
		// Note: to_utc_time parameter must not be specified to subscribe.
		SUBSCRIBE = 2;

		// Drop request if server has not completed it yet and/or unsubscribe if already subscribed for updates.
		DROP = 3;
	}
	// This field is associated with RequestType enum type. GET operation is processed by default.
	optional uint32 request_type = 3;
}

// Time bar.
message TimeBar
{
	// Bar start time (UTC).
	required sint64 bar_utc_time = 1;

	// Open price.
	optional sint32 open_price = 2;

	// High price.
	optional sint32 high_price = 3;

	// Low price.
	optional sint32 low_price = 4;

	// Close or last price (if the bar is not closed yet).
	// It is omitted if the TimeBarParameters.use_settlements is true.
	optional sint32 close_price = 5;

	// Bar volume.
	optional uint64 volume = 6;

	// Trade date (in time format), it is set only for the first bar in a requested period
	// and for each first bar of the following trade dates for intra-day bars. Trade date of the bar first day for multi-day bars.
	optional sint64 trade_date = 7;

	// Commodity volume where available, for multi-day bars only.
	optional uint64 commodity_volume = 8;

	// Open interest, for multi-day bars only.
	optional uint32 open_interest = 9;

	// Commodity open interest, for multi-day bars only.
	optional uint32 commodity_open_interest = 10;
	
	// Settlement price, for daily bars only.
	// It is omitted if the TimeBarParameters.use_settlements is false or omitted.
	optional sint32 settlement_price = 11;
}

// Time bar data response or update.
// Each report contains set of bars. Reports related to a specific request ordered chronologically from the most recent one to the past.
// In case of subscription each report contains 'up_to_utc_time' field.
// Warning: bar updates are not synchronized with real time data so a real time quote that is included into
// a bar might be received either before or after the bar update, use time of a quote for possible real-time bar updates.
message TimeBarReport
{
	// ID of a corresponding request or subscription.
	required uint32 request_id = 1;

	// Status code.
	enum StatusCode
	{
		/// success codes  (0 - 99)
		// Request is processed without subscription (subscription was not requested).
		SUCCESS = 0;

		// Request is processed and subscription is established or restored after disconnection.
		// Data can be resent as a result of the restored subscription.
		SUBSCRIBED = 1;

		// Subscription or delayed request is dropped by a client.
		DROPPED = 2;

		// Unsolicited information update because of subscription.
		UPDATE = 3;

		// Subscription or request processing status that indicates that currently processing is impossible because of communication issues.
		// NOTE: Clients should not resubscribe or resend requests in this case, the server will restore processing with 
		// sending SUCCESS or SUBSCRIBED status once communication issues are resolved.
		// If client is not interested in this request or subscription any longer it should send DROP request.
		DISCONNECTED = 4;

		/// failure codes (100+), subscription (if any) is dropped in case of failure.
		// General failure.
		FAILURE = 101;

		// The user is not allowed to access this data.
		ACCESS_DENIED = 103;

		// Requested information is not found.
		NOT_FOUND = 104; 

		// Requested data is outside of allowed range.
		OUTSIDE_ALLOWED_RANGE = 105;

		// Parameters of a time bar request are invalid.
		INVALID_PARAMS = 106;
	}
	// This field is associated with StatusCode enum type.
	required uint32 status_code = 2;

	// List of time bars.
	repeated TimeBar time_bar = 3;

	// Time up to which the quotes were included into bars, 
	// if there were several with the same time-stamp equal to this time then all are included into the last bar (UTC).
	// This time is set for 'up-to-current' bar requests and bar updates.
	optional int64 up_to_utc_time  = 4;

	// True means that requested data is complete at the moment, false means more report messages are expected for completeness.
	optional bool is_report_complete = 5 [default = true];

	// Optional failure details.
	optional string text_message = 6;

	// Request contains dates partially outside of allowed historical data depth.
	optional bool truncated = 7;
}

// Historical orders request.
message HistoricalOrdersRequest
{
	// Only orders from specified business date (inclusively) is to be returned (date only value in time format).
	required sint64 from_date = 1;

	// Only orders till specified business date (inclusively) is to be returned (date only value in time format).
	// Current business day if the field is omitted.
	optional sint64 to_date = 2;

	// Filter orders by account. Not specifying any account means all accounts of the user.
	repeated sint32 account_id = 3;
}

// Response for historical orders request.
message HistoricalOrdersReport
{
	// List of order statuses matching historical order filter.
	repeated OrderStatus order_status = 1;
}
